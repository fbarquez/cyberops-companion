"""
Vulnerability Management Service.

Business logic for vulnerability management operations.
"""
import logging
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any, Tuple
from uuid import uuid4

from sqlalchemy import select, func, and_, or_, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from src.models.vulnerability import (
    Asset, CVEEntry, Vulnerability, VulnerabilityComment,
    VulnerabilityScan, ScanSchedule,
    VulnerabilitySeverity, VulnerabilityStatus, ScanStatus,
    AssetCriticality
)
from src.schemas.vulnerability import (
    AssetCreate, AssetUpdate,
    CVECreate,
    VulnerabilityCreate, VulnerabilityUpdate, VulnerabilityStatusUpdate,
    VulnerabilityCommentCreate,
    ScanCreate, ScanScheduleCreate,
    VulnerabilityImport
)

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Service for vulnerability management operations."""

    # Risk score weights
    SEVERITY_WEIGHTS = {
        VulnerabilitySeverity.CRITICAL: 10.0,
        VulnerabilitySeverity.HIGH: 7.5,
        VulnerabilitySeverity.MEDIUM: 5.0,
        VulnerabilitySeverity.LOW: 2.5,
        VulnerabilitySeverity.INFO: 0.5,
    }

    CRITICALITY_MULTIPLIERS = {
        AssetCriticality.CRITICAL: 1.5,
        AssetCriticality.HIGH: 1.25,
        AssetCriticality.MEDIUM: 1.0,
        AssetCriticality.LOW: 0.75,
    }

    # ==================== Asset Operations ====================

    async def create_asset(
        self,
        db: AsyncSession,
        data: AssetCreate,
        user_id: Optional[str] = None
    ) -> Asset:
        """Create a new asset."""
        asset = Asset(
            id=str(uuid4()),
            **data.model_dump()
        )
        db.add(asset)
        await db.commit()
        await db.refresh(asset)

        logger.info(f"Created asset: {asset.name} ({asset.id})")
        return asset

    async def get_asset(self, db: AsyncSession, asset_id: str) -> Optional[Asset]:
        """Get an asset by ID."""
        result = await db.execute(
            select(Asset)
            .options(selectinload(Asset.vulnerabilities))
            .where(Asset.id == asset_id)
        )
        return result.scalar_one_or_none()

    async def list_assets(
        self,
        db: AsyncSession,
        search: Optional[str] = None,
        asset_type: Optional[str] = None,
        criticality: Optional[str] = None,
        environment: Optional[str] = None,
        is_active: Optional[bool] = True,
        page: int = 1,
        page_size: int = 50
    ) -> Tuple[List[Asset], int]:
        """List assets with filtering and pagination."""
        query = select(Asset)
        count_query = select(func.count(Asset.id))

        # Apply filters
        conditions = []
        if search:
            search_filter = or_(
                Asset.name.ilike(f"%{search}%"),
                Asset.hostname.ilike(f"%{search}%"),
                Asset.ip_address.ilike(f"%{search}%"),
                Asset.fqdn.ilike(f"%{search}%")
            )
            conditions.append(search_filter)

        if asset_type:
            conditions.append(Asset.asset_type == asset_type)
        if criticality:
            conditions.append(Asset.criticality == criticality)
        if environment:
            conditions.append(Asset.environment == environment)
        if is_active is not None:
            conditions.append(Asset.is_active == is_active)

        if conditions:
            query = query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))

        # Get total count
        total_result = await db.execute(count_query)
        total = total_result.scalar()

        # Apply pagination
        offset = (page - 1) * page_size
        query = query.order_by(desc(Asset.created_at)).offset(offset).limit(page_size)

        result = await db.execute(query)
        assets = result.scalars().all()

        return list(assets), total

    async def update_asset(
        self,
        db: AsyncSession,
        asset_id: str,
        data: AssetUpdate
    ) -> Optional[Asset]:
        """Update an asset."""
        asset = await self.get_asset(db, asset_id)
        if not asset:
            return None

        update_data = data.model_dump(exclude_unset=True)
        for key, value in update_data.items():
            setattr(asset, key, value)

        await db.commit()
        await db.refresh(asset)
        return asset

    async def delete_asset(self, db: AsyncSession, asset_id: str) -> bool:
        """Delete an asset."""
        asset = await self.get_asset(db, asset_id)
        if not asset:
            return False

        await db.delete(asset)
        await db.commit()
        return True

    # ==================== CVE Operations ====================

    async def get_or_create_cve(
        self,
        db: AsyncSession,
        cve_id: str,
        data: Optional[CVECreate] = None
    ) -> CVEEntry:
        """Get existing CVE or create new one."""
        result = await db.execute(
            select(CVEEntry).where(CVEEntry.cve_id == cve_id)
        )
        cve = result.scalar_one_or_none()

        if cve:
            return cve

        # Create new CVE entry
        cve = CVEEntry(
            id=str(uuid4()),
            cve_id=cve_id,
            **(data.model_dump() if data else {})
        )
        db.add(cve)
        await db.commit()
        await db.refresh(cve)
        return cve

    async def lookup_cve(self, db: AsyncSession, cve_id: str) -> Optional[Dict[str, Any]]:
        """
        Lookup CVE information from NVD.

        Fetches data from:
        - NVD API 2.0 (CVE details, CVSS scores)
        - EPSS API (exploit prediction scores)
        - CISA KEV catalog (known exploited vulnerabilities)

        Args:
            db: Database session
            cve_id: CVE ID (e.g., "CVE-2021-44228")

        Returns:
            Dictionary with CVE data or None if not found
        """
        from src.services.nvd_service import get_nvd_service

        nvd_service = get_nvd_service()
        cve_data = await nvd_service.get_cve(cve_id)

        if cve_data:
            return cve_data.to_dict()

        # Fallback for invalid or not found CVEs
        return None

    async def enrich_cve(
        self,
        db: AsyncSession,
        cve_id: str,
        create_if_missing: bool = True
    ) -> Optional[CVEEntry]:
        """
        Enrich or create a CVE entry with data from NVD.

        Args:
            db: Database session
            cve_id: CVE ID to enrich
            create_if_missing: Create entry if it doesn't exist

        Returns:
            Updated or created CVEEntry
        """
        from src.services.nvd_service import get_nvd_service

        # Check if CVE exists in database
        result = await db.execute(
            select(CVEEntry).where(CVEEntry.cve_id == cve_id)
        )
        existing = result.scalar_one_or_none()

        # Fetch from NVD
        nvd_service = get_nvd_service()
        cve_data = await nvd_service.get_cve(cve_id)

        if not cve_data:
            logger.warning(f"CVE {cve_id} not found in NVD")
            return existing

        # Map severity string to enum
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "none": VulnerabilitySeverity.INFO,
        }
        severity = severity_map.get(cve_data.severity, VulnerabilitySeverity.MEDIUM) if cve_data.severity else None

        if existing:
            # Update existing entry
            existing.description = cve_data.description
            existing.cvss_score = cve_data.cvss_score
            existing.cvss_version = cve_data.cvss_version
            existing.cvss_vector = cve_data.cvss_vector
            existing.severity = severity
            existing.epss_score = cve_data.epss_score
            existing.epss_percentile = cve_data.epss_percentile
            existing.is_kev = cve_data.is_kev
            existing.kev_date_added = cve_data.kev_date_added
            existing.kev_due_date = cve_data.kev_due_date
            existing.references = [ref.get("url") for ref in cve_data.references if ref.get("url")]
            existing.cwe_ids = cve_data.cwe_ids
            existing.affected_cpe = cve_data.affected_cpe
            existing.published_date = cve_data.published_date
            existing.modified_date = cve_data.modified_date
            existing.updated_at = datetime.utcnow()

            await db.commit()
            await db.refresh(existing)
            logger.info(f"Enriched existing CVE: {cve_id}")
            return existing

        elif create_if_missing:
            # Create new entry
            new_cve = CVEEntry(
                id=str(uuid4()),
                cve_id=cve_id,
                description=cve_data.description,
                cvss_score=cve_data.cvss_score,
                cvss_version=cve_data.cvss_version,
                cvss_vector=cve_data.cvss_vector,
                severity=severity,
                epss_score=cve_data.epss_score,
                epss_percentile=cve_data.epss_percentile,
                is_kev=cve_data.is_kev,
                kev_date_added=cve_data.kev_date_added,
                kev_due_date=cve_data.kev_due_date,
                references=[ref.get("url") for ref in cve_data.references if ref.get("url")],
                cwe_ids=cve_data.cwe_ids,
                affected_cpe=cve_data.affected_cpe,
                published_date=cve_data.published_date,
                modified_date=cve_data.modified_date,
            )
            db.add(new_cve)
            await db.commit()
            await db.refresh(new_cve)
            logger.info(f"Created CVE from NVD: {cve_id}")
            return new_cve

        return None

    # ==================== Vulnerability Operations ====================

    def calculate_risk_score(
        self,
        severity: VulnerabilitySeverity,
        cvss_score: Optional[float],
        asset_criticality: Optional[AssetCriticality] = None
    ) -> float:
        """Calculate risk score based on severity, CVSS, and asset criticality."""
        # Base score from severity
        base_score = self.SEVERITY_WEIGHTS.get(severity, 5.0)

        # Adjust with CVSS if available
        if cvss_score is not None:
            base_score = cvss_score

        # Apply asset criticality multiplier
        if asset_criticality:
            multiplier = self.CRITICALITY_MULTIPLIERS.get(asset_criticality, 1.0)
            base_score *= multiplier

        return min(base_score, 10.0)  # Cap at 10

    async def create_vulnerability(
        self,
        db: AsyncSession,
        data: VulnerabilityCreate,
        user_id: Optional[str] = None
    ) -> Vulnerability:
        """Create a new vulnerability."""
        # Get highest asset criticality
        max_criticality = None
        if data.asset_ids:
            result = await db.execute(
                select(Asset.criticality).where(Asset.id.in_(data.asset_ids))
            )
            criticalities = result.scalars().all()
            if criticalities:
                priority = [AssetCriticality.CRITICAL, AssetCriticality.HIGH, AssetCriticality.MEDIUM, AssetCriticality.LOW]
                for p in priority:
                    if p in criticalities:
                        max_criticality = p
                        break

        # Calculate risk score
        risk_score = self.calculate_risk_score(
            data.severity,
            data.cvss_score,
            max_criticality
        )

        vuln = Vulnerability(
            id=str(uuid4()),
            title=data.title,
            description=data.description,
            severity=data.severity,
            cvss_score=data.cvss_score,
            cvss_vector=data.cvss_vector,
            vulnerability_type=data.vulnerability_type,
            affected_component=data.affected_component,
            affected_version=data.affected_version,
            remediation_steps=data.remediation_steps,
            detected_by=data.detected_by,
            proof=data.proof,
            tags=data.tags,
            risk_score=risk_score,
            first_detected=datetime.utcnow(),
            last_detected=datetime.utcnow(),
            created_by=user_id
        )

        # Link assets
        if data.asset_ids:
            result = await db.execute(
                select(Asset).where(Asset.id.in_(data.asset_ids))
            )
            assets = result.scalars().all()
            vuln.affected_assets = list(assets)

        # Link CVEs
        if data.cve_ids:
            for cve_id in data.cve_ids:
                cve = await self.get_or_create_cve(db, cve_id)
                vuln.cves.append(cve)

        db.add(vuln)
        await db.commit()
        await db.refresh(vuln)

        logger.info(f"Created vulnerability: {vuln.title} ({vuln.id}) - {vuln.severity.value}")
        return vuln

    async def get_vulnerability(
        self,
        db: AsyncSession,
        vuln_id: str
    ) -> Optional[Vulnerability]:
        """Get a vulnerability by ID with related data."""
        result = await db.execute(
            select(Vulnerability)
            .options(
                selectinload(Vulnerability.affected_assets),
                selectinload(Vulnerability.cves),
                selectinload(Vulnerability.comments)
            )
            .where(Vulnerability.id == vuln_id)
        )
        return result.scalar_one_or_none()

    async def list_vulnerabilities(
        self,
        db: AsyncSession,
        search: Optional[str] = None,
        severity: Optional[str] = None,
        status: Optional[str] = None,
        asset_id: Optional[str] = None,
        scan_id: Optional[str] = None,
        assigned_to: Optional[str] = None,
        overdue_only: bool = False,
        page: int = 1,
        page_size: int = 50
    ) -> Tuple[List[Vulnerability], int]:
        """List vulnerabilities with filtering and pagination."""
        query = select(Vulnerability).options(
            selectinload(Vulnerability.affected_assets),
            selectinload(Vulnerability.cves)
        )
        count_query = select(func.count(Vulnerability.id))

        conditions = []
        if search:
            search_filter = or_(
                Vulnerability.title.ilike(f"%{search}%"),
                Vulnerability.description.ilike(f"%{search}%"),
                Vulnerability.affected_component.ilike(f"%{search}%")
            )
            conditions.append(search_filter)

        if severity:
            conditions.append(Vulnerability.severity == severity)
        if status:
            conditions.append(Vulnerability.status == status)
        if scan_id:
            conditions.append(Vulnerability.scan_id == scan_id)
        if assigned_to:
            conditions.append(Vulnerability.assigned_to == assigned_to)
        if overdue_only:
            conditions.append(Vulnerability.remediation_deadline < datetime.utcnow())
            conditions.append(Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]))

        if asset_id:
            query = query.join(Vulnerability.affected_assets).where(Asset.id == asset_id)
            count_query = count_query.join(Vulnerability.affected_assets).where(Asset.id == asset_id)

        if conditions:
            query = query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))

        # Get total count
        total_result = await db.execute(count_query)
        total = total_result.scalar()

        # Apply pagination and ordering
        offset = (page - 1) * page_size
        query = query.order_by(
            desc(Vulnerability.risk_score),
            desc(Vulnerability.created_at)
        ).offset(offset).limit(page_size)

        result = await db.execute(query)
        vulnerabilities = result.scalars().unique().all()

        return list(vulnerabilities), total

    async def update_vulnerability(
        self,
        db: AsyncSession,
        vuln_id: str,
        data: VulnerabilityUpdate,
        user_id: Optional[str] = None
    ) -> Optional[Vulnerability]:
        """Update a vulnerability."""
        vuln = await self.get_vulnerability(db, vuln_id)
        if not vuln:
            return None

        update_data = data.model_dump(exclude_unset=True)
        for key, value in update_data.items():
            setattr(vuln, key, value)

        # Recalculate risk score if severity changed
        if 'severity' in update_data or 'cvss_score' in update_data:
            max_criticality = None
            if vuln.affected_assets:
                priority = [AssetCriticality.CRITICAL, AssetCriticality.HIGH, AssetCriticality.MEDIUM, AssetCriticality.LOW]
                for p in priority:
                    if any(a.criticality == p for a in vuln.affected_assets):
                        max_criticality = p
                        break
            vuln.risk_score = self.calculate_risk_score(
                vuln.severity,
                vuln.cvss_score,
                max_criticality
            )

        await db.commit()
        await db.refresh(vuln)
        return vuln

    async def update_vulnerability_status(
        self,
        db: AsyncSession,
        vuln_id: str,
        data: VulnerabilityStatusUpdate,
        user_id: Optional[str] = None
    ) -> Optional[Vulnerability]:
        """Update vulnerability status with audit trail."""
        vuln = await self.get_vulnerability(db, vuln_id)
        if not vuln:
            return None

        old_status = vuln.status
        vuln.status = data.status

        # Handle specific status transitions
        if data.status == VulnerabilityStatus.REMEDIATED:
            vuln.remediated_at = datetime.utcnow()
            vuln.remediated_by = user_id
        elif data.status == VulnerabilityStatus.ACCEPTED:
            vuln.risk_accepted_at = datetime.utcnow()
            vuln.risk_accepted_by = user_id
            vuln.risk_acceptance_reason = data.risk_acceptance_reason
            vuln.risk_acceptance_expiry = data.risk_acceptance_expiry

        # Add status change comment
        if data.comment:
            comment = VulnerabilityComment(
                id=str(uuid4()),
                vulnerability_id=vuln_id,
                content=f"Status changed from {old_status.value} to {data.status.value}: {data.comment}",
                comment_type="status_change",
                created_by=user_id
            )
            db.add(comment)

        await db.commit()
        await db.refresh(vuln)

        logger.info(f"Vulnerability {vuln_id} status changed: {old_status.value} -> {data.status.value}")
        return vuln

    async def add_comment(
        self,
        db: AsyncSession,
        vuln_id: str,
        data: VulnerabilityCommentCreate,
        user_id: Optional[str] = None
    ) -> VulnerabilityComment:
        """Add a comment to a vulnerability."""
        comment = VulnerabilityComment(
            id=str(uuid4()),
            vulnerability_id=vuln_id,
            content=data.content,
            comment_type=data.comment_type,
            created_by=user_id
        )
        db.add(comment)
        await db.commit()
        await db.refresh(comment)
        return comment

    async def delete_vulnerability(self, db: AsyncSession, vuln_id: str) -> bool:
        """Delete a vulnerability."""
        vuln = await self.get_vulnerability(db, vuln_id)
        if not vuln:
            return False

        await db.delete(vuln)
        await db.commit()
        return True

    # ==================== Scan Operations ====================

    async def create_scan(
        self,
        db: AsyncSession,
        data: ScanCreate,
        user_id: Optional[str] = None
    ) -> VulnerabilityScan:
        """Create a new scan."""
        scan = VulnerabilityScan(
            id=str(uuid4()),
            name=data.name,
            scan_type=data.scan_type,
            scanner=data.scanner,
            target_asset_id=data.target_asset_id,
            target_scope=data.target_scope,
            scan_config=data.scan_config,
            scheduled_at=data.scheduled_at,
            status=ScanStatus.PENDING,
            created_by=user_id
        )
        db.add(scan)
        await db.commit()
        await db.refresh(scan)

        logger.info(f"Created scan: {scan.name} ({scan.id})")
        return scan

    async def get_scan(self, db: AsyncSession, scan_id: str) -> Optional[VulnerabilityScan]:
        """Get a scan by ID."""
        result = await db.execute(
            select(VulnerabilityScan)
            .options(selectinload(VulnerabilityScan.findings))
            .where(VulnerabilityScan.id == scan_id)
        )
        return result.scalar_one_or_none()

    async def list_scans(
        self,
        db: AsyncSession,
        scan_type: Optional[str] = None,
        status: Optional[str] = None,
        page: int = 1,
        page_size: int = 50
    ) -> Tuple[List[VulnerabilityScan], int]:
        """List scans with filtering and pagination."""
        query = select(VulnerabilityScan)
        count_query = select(func.count(VulnerabilityScan.id))

        conditions = []
        if scan_type:
            conditions.append(VulnerabilityScan.scan_type == scan_type)
        if status:
            conditions.append(VulnerabilityScan.status == status)

        if conditions:
            query = query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))

        total_result = await db.execute(count_query)
        total = total_result.scalar()

        offset = (page - 1) * page_size
        query = query.order_by(desc(VulnerabilityScan.created_at)).offset(offset).limit(page_size)

        result = await db.execute(query)
        scans = result.scalars().all()

        return list(scans), total

    async def start_scan(
        self,
        db: AsyncSession,
        scan_id: str
    ) -> Optional[VulnerabilityScan]:
        """Start a scan execution."""
        scan = await self.get_scan(db, scan_id)
        if not scan or scan.status != ScanStatus.PENDING:
            return None

        scan.status = ScanStatus.RUNNING
        scan.started_at = datetime.utcnow()

        await db.commit()
        await db.refresh(scan)

        # TODO: Trigger actual scan execution (e.g., via Celery task)
        logger.info(f"Started scan: {scan.name} ({scan.id})")
        return scan

    async def complete_scan(
        self,
        db: AsyncSession,
        scan_id: str,
        findings_count: Dict[str, int],
        error: Optional[str] = None
    ) -> Optional[VulnerabilityScan]:
        """Mark a scan as completed."""
        scan = await self.get_scan(db, scan_id)
        if not scan:
            return None

        scan.completed_at = datetime.utcnow()
        scan.status = ScanStatus.FAILED if error else ScanStatus.COMPLETED
        scan.error_message = error

        if not error:
            scan.critical_count = findings_count.get('critical', 0)
            scan.high_count = findings_count.get('high', 0)
            scan.medium_count = findings_count.get('medium', 0)
            scan.low_count = findings_count.get('low', 0)
            scan.info_count = findings_count.get('info', 0)
            scan.total_findings = sum(findings_count.values())

        await db.commit()
        await db.refresh(scan)
        return scan

    # ==================== Statistics ====================

    async def get_statistics(self, db: AsyncSession) -> Dict[str, Any]:
        """Get vulnerability management statistics."""
        now = datetime.utcnow()
        thirty_days_ago = now - timedelta(days=30)

        # Vulnerability counts by status
        status_result = await db.execute(
            select(Vulnerability.status, func.count(Vulnerability.id))
            .group_by(Vulnerability.status)
        )
        by_status = {str(row[0].value): row[1] for row in status_result.fetchall()}

        # Vulnerability counts by severity
        severity_result = await db.execute(
            select(Vulnerability.severity, func.count(Vulnerability.id))
            .group_by(Vulnerability.severity)
        )
        by_severity = {str(row[0].value): row[1] for row in severity_result.fetchall()}

        # Total vulnerabilities
        total_result = await db.execute(select(func.count(Vulnerability.id)))
        total_vulnerabilities = total_result.scalar()

        # Open vulnerabilities
        open_result = await db.execute(
            select(func.count(Vulnerability.id))
            .where(Vulnerability.status == VulnerabilityStatus.OPEN)
        )
        open_vulnerabilities = open_result.scalar()

        # In progress
        in_progress_result = await db.execute(
            select(func.count(Vulnerability.id))
            .where(Vulnerability.status == VulnerabilityStatus.IN_PROGRESS)
        )
        in_progress = in_progress_result.scalar()

        # Remediated
        remediated_result = await db.execute(
            select(func.count(Vulnerability.id))
            .where(Vulnerability.status == VulnerabilityStatus.REMEDIATED)
        )
        remediated = remediated_result.scalar()

        # Total assets
        assets_result = await db.execute(
            select(func.count(Asset.id)).where(Asset.is_active == True)
        )
        total_assets = assets_result.scalar()

        # Assets with vulnerabilities
        assets_with_vulns_result = await db.execute(
            select(func.count(func.distinct(Asset.id)))
            .select_from(Asset)
            .join(Asset.vulnerabilities)
            .where(Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]))
        )
        assets_with_vulns = assets_with_vulns_result.scalar() or 0

        # Scan counts
        total_scans_result = await db.execute(select(func.count(VulnerabilityScan.id)))
        total_scans = total_scans_result.scalar()

        recent_scans_result = await db.execute(
            select(func.count(VulnerabilityScan.id))
            .where(VulnerabilityScan.created_at >= thirty_days_ago)
        )
        recent_scans = recent_scans_result.scalar()

        # Overdue vulnerabilities
        overdue_result = await db.execute(
            select(func.count(Vulnerability.id))
            .where(
                and_(
                    Vulnerability.remediation_deadline < now,
                    Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS])
                )
            )
        )
        overdue = overdue_result.scalar()

        # Mean time to remediate (for vulnerabilities remediated in last 30 days)
        mttr_result = await db.execute(
            select(
                func.avg(
                    func.extract('epoch', Vulnerability.remediated_at) -
                    func.extract('epoch', Vulnerability.first_detected)
                )
            )
            .where(
                and_(
                    Vulnerability.status == VulnerabilityStatus.REMEDIATED,
                    Vulnerability.remediated_at >= thirty_days_ago
                )
            )
        )
        mttr_seconds = mttr_result.scalar()
        mttr_days = round(mttr_seconds / 86400, 1) if mttr_seconds else None

        # Top vulnerable assets
        top_assets_result = await db.execute(
            select(
                Asset.id,
                Asset.name,
                Asset.criticality,
                func.count(Vulnerability.id).label('vuln_count')
            )
            .join(Asset.vulnerabilities)
            .where(Vulnerability.status.in_([VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]))
            .group_by(Asset.id, Asset.name, Asset.criticality)
            .order_by(desc('vuln_count'))
            .limit(5)
        )
        top_assets = [
            {
                "id": row[0],
                "name": row[1],
                "criticality": str(row[2].value) if row[2] else "unknown",
                "vulnerability_count": row[3]
            }
            for row in top_assets_result.fetchall()
        ]

        # Recent vulnerabilities
        recent_vulns_result = await db.execute(
            select(Vulnerability)
            .options(selectinload(Vulnerability.affected_assets))
            .order_by(desc(Vulnerability.created_at))
            .limit(10)
        )
        recent_vulns = recent_vulns_result.scalars().all()

        return {
            "total_vulnerabilities": total_vulnerabilities,
            "open_vulnerabilities": open_vulnerabilities,
            "in_progress_vulnerabilities": in_progress,
            "remediated_vulnerabilities": remediated,
            "by_severity": by_severity,
            "by_status": by_status,
            "total_assets": total_assets,
            "assets_with_vulnerabilities": assets_with_vulns,
            "total_scans": total_scans,
            "scans_last_30_days": recent_scans,
            "mean_time_to_remediate_days": mttr_days,
            "overdue_vulnerabilities": overdue,
            "top_vulnerable_assets": top_assets,
            "recent_vulnerabilities": recent_vulns
        }

    # ==================== Import Operations ====================

    async def import_scan_results(
        self,
        db: AsyncSession,
        data: VulnerabilityImport,
        user_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """Import vulnerabilities from scanner output."""
        imported = 0
        updated = 0
        skipped = 0
        errors = []

        # Create a scan record
        scan = VulnerabilityScan(
            id=str(uuid4()),
            name=f"Import from {data.scanner}",
            scan_type="network",  # Default
            scanner=data.scanner,
            status=ScanStatus.COMPLETED,
            started_at=data.scan_date or datetime.utcnow(),
            completed_at=datetime.utcnow(),
            created_by=user_id
        )
        db.add(scan)

        severity_counts = {
            'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0
        }

        for finding in data.findings:
            try:
                # Map severity
                severity_str = finding.get('severity', 'medium').lower()
                severity = VulnerabilitySeverity(severity_str) if severity_str in [s.value for s in VulnerabilitySeverity] else VulnerabilitySeverity.MEDIUM

                severity_counts[severity.value] += 1

                vuln = Vulnerability(
                    id=str(uuid4()),
                    title=finding.get('title', 'Unknown Vulnerability'),
                    description=finding.get('description'),
                    severity=severity,
                    cvss_score=finding.get('cvss_score'),
                    cvss_vector=finding.get('cvss_vector'),
                    vulnerability_type=finding.get('type'),
                    affected_component=finding.get('affected_component'),
                    affected_version=finding.get('affected_version'),
                    detected_by=data.scanner,
                    proof=finding.get('proof'),
                    remediation_steps=finding.get('remediation'),
                    first_detected=datetime.utcnow(),
                    last_detected=datetime.utcnow(),
                    scan_id=scan.id,
                    created_by=user_id
                )

                # Calculate risk score
                vuln.risk_score = self.calculate_risk_score(severity, vuln.cvss_score)

                db.add(vuln)
                imported += 1

            except Exception as e:
                errors.append(f"Error importing finding: {str(e)}")
                skipped += 1

        # Update scan counts
        scan.total_findings = imported
        scan.critical_count = severity_counts['critical']
        scan.high_count = severity_counts['high']
        scan.medium_count = severity_counts['medium']
        scan.low_count = severity_counts['low']
        scan.info_count = severity_counts['info']

        await db.commit()

        logger.info(f"Imported {imported} vulnerabilities from {data.scanner}")

        return {
            "imported": imported,
            "updated": updated,
            "skipped": skipped,
            "errors": errors,
            "scan_id": scan.id
        }
